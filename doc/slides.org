#+title: 3rd Session: a working program
#+author: Pau Cervera & Cristobal Garcia
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: num:nil


* Intro

To implement a small single-user TO-DO list as a web application. To be able
to focus on learning, we will use the provided skeleton app and work in
_fill-in-the-blanks_ mode.

** Repo structure

   The [[https://github.com/capside-functional-nomads/bartleby][repo]] has some intereting tags

   - =bare-bones= web infrastructure in place. No features.
   - =starting-point= sample features implemented.

** Agenda

   - Show the starting point (=starting-point= tag) while explaining
     - Recap of LISP/clojure syntax
     - Recap of lists, vectors and maps
     - Functions and destructuring
     - Namespaces
     - Your first 10' with web apps in clojure
       - ring apps from =bare-bones=
       - compojure from =starting-point=
     - Your first 10' with clojurescript and re-frame (from =starting-point=)
     - Q&A
     - Code the features:
       - Create a new task
       - Mark a task as completed
       - Delete a task

* Starting

  1. clone the repo
  2. start the database
  3. =lein trampoline run=
  4. Implement the user stories 


* Reference

  - [[https://github.com/ring-clojure/ring/wiki/Concepts][Ring concepts]]


* Recap: LISP, clojure syntax

** Function application

  #+begin_src clojure :eval never
  ;; function application
  (+ 1 1)
  ;;=> 2

  (first '(1 2 3))
  ;;=> 1
  #+end_src

** Conditionals

  #+begin_src clojure :eval never
    (> 2 1)
    ;;=> true
    (> 2 2)
    ;;=> false
    (nil? 1)
    ;;=> false
    (nil? nil)
    ;;=> true
    (if (nil? 1) "1 is nil!" "Good!")
    ;;=>"Good!"
    (when (nil? 1) "1 is nil!")
    ;;=>nil
  #+end_src

** Lists
  
  #+begin_src clojure :eval never
  '(1 2 3)
  (first '(1 2 3))
  ;;=> 1
  (rest '(1 2 3))
  ;;=> (2 3)
  (conj '(1 2) 3)
  ;;=> (3 1 2)
  #+end_src

** Vectors

  #+begin_src clojure :eval never
  [1 2 3]
  (first [1 2 3])
  ;;=> 1
  (rest [1 2 3])
  ;;=> [2 3]
  (conj [1 2] 3)
  ;;=> [1 2 3]
  #+end_src

** Maps

  #+begin_src clojure :eval never
  {:a 1 :b "2"}
  (:a {:a 1 :b "2"})
  ;;=>1
  (:c {:a 1 :b "2"})
  ;;=>nil
  (conj {:a 1 :b "2"} [:c 'tres])
  ;;=>{:a 1 :b "2" :c tres}
  #+end_src

** Defining functions

  #+begin_src clojure :eval never
    (defn add-2
      [x]
      (+ x 2))
  #+end_src

** Lexical scoping

   - In clojure we normally do not use _global_ items
   - Functions use lexical contexts to define auxiliar symbols

  #+begin_src clojure :eval never
    (defn strange-math-op
      [x y]
      (let [double-x (* 2 x)
            triple-y (* 3 y)]
        (+ double-x triple-y)))
        
  #+end_src

** Destructuring


* Recap: Lists, vectors and maps

* Functions and descructuring

* Namespaces

* DB Setup

  create user fakere with login, encrypted password 'fakere';
  create database fakere with owner=fakere,encoding=utf8;
